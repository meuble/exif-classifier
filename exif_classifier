#!/usr/bin/ruby
#
## exif_classifier
## ---------------
##
## Classify your pictures from their EXIF entry.
##
## Usage: exif_classifier [options] picture_or_directory [,picture_or_directory,...] destination_root
##
## Default tree is destination/yyyy/mm/date.ext
##
require 'pathname'
require 'rubygems'
require 'exifr'

require 'optparse'

class ExifClassifier
  REFUSAL_REASON = [ :unreadable, :no_exif, :filter ]
  REFUSAL_TEXT   = { :unreadable => 'Unreadable file', :no_exif => 'No EXIF info', :filter => 'Excluded from file filter' } 

  attr_reader :options
  
  def initialize
    @failed_copy     = []
    @succeed_copy    = []
    @staged_images   = []
    @refused_entries = []
  end

  def usage
    open(__FILE__).read.grep(/^## ?/).join.gsub(/^## ?/, '')
  end

  def opts_valid?
    !@options[:destination].nil? && Pathname.new(@options[:destination]).exist? && !(@options[:sources] || []).empty?
  end

  def parse_opts
    @options = {
          :pattern => '%Y/%m/%Y%m%d-%H%M%S',
          :delete  => false,
          :dry     => false,
          :verbose => false,
          :accepted_files    => ['jpeg', 'jpg' ],
          :ignore_if_no_exif => true,
          :sources     => '',
          :destination => './'
    }
    opts = OptionParser.new
    opts.banner = usage
    opts.on('-p','--pattern PATTERN', "output pattern") { |pattern| @options[:pattern] = pattern }
    opts.on('-k','--delete', "delete original files once proceed") { @options[:delete] = true } 
    opts.on('-d','--dry', "dry run") { @options[:dry] = true } 
    opts.on('-h','--help', "this help screen") { puts opts; exit(0) } 
    opts.parse!
    # Remainings in ARGV are sources, the last one is the destination
    @options[:destination] = ARGV.delete_at(-1)
    @options[:sources]     = ARGV
    if opts_valid?
      stage(@options[:sources])
      return true
    end
    
    puts opts
    exit(-1)
  end

  def report
    content = %{
      Staged files  : #{@staged_images.length}
      Failed files  : #{@failed_copy.length}
      Proceed files : #{@succeed_copy.length}
    }
    puts content
  end

  # stage for processing files or directories, or a mix
  # of those.
  def stage(files_or_directories = [])
    files_or_directories = [files_or_directories] unless files_or_directories.instance_of?(Array)
    files_or_directories.each do |file_or_directory|
      pathname = Pathname.new(file_or_directory)
      return stage(pathname.children) if pathname.directory?
      if pathname.readable?
        @staged_images << pathname
      else
        @refused_entries << pathname
        puts "Can't read: #{pathname.to_s}"
        raise file_or_directory.to_s
      end
    end
    puts "#{@staged_images.length} files staged for processing" if @options[:verbose]
    @staged_images.inspect
  end
  
  def get_target_pathname(picture_pathname)
    begin
      pattern = EXIFR::JPEG.new(picture_pathname.to_s).date_time.strftime(@options[:pattern])
    rescue RuntimeError => e
      puts "Can't retrieve EXIF from #{picture_pathname}: #{e.message}"
      return nil
    end
    pathname = Pathname.new("#{@options[:destination]}/#{pattern}#{picture_pathname.extname.downcase}")
  end

  def process
    @staged_images.each do |pathname|
      classify(pathname)
    end
  end

  def classify(picture)
    puts "Classify: #{picture}" if @options[:verbose]
    target_file = get_target_pathname(picture)
    unless target_file
      puts "Abort classification for #{picture}"
      return nil
    end
    # TODO rescue SystemCallError
    target_file.dirname.mkpath
    FileUtils.copy_file(picture.to_s, target_file.to_s, true)
    if FileUtils.compare_file(picture.to_s, target_file.to_s)
      @succeed_copy << picture
    else
      @failed_copy << picture
    end
  end

  def delete_succeed_sources
    @succeed_copy.each { |pathname| Filecopy.rm(pathname.to_sh) }
  end

end

if __FILE__ == $0
  classifier = ExifClassifier.new
  classifier.parse_opts
  classifier.process
  classifier.report
end
