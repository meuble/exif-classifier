#!/usr/bin/ruby
#
## exif_classifier
## ---------------
##
## Classify your pictures from their EXIF entry.
##
## Usage: exif_classifier [options] picture_or_directory [,picture_or_directory,...] destination_root
##
## Default tree is destination/yyyy/mm/date.ext
##
require 'pathname'
require 'rubygems'
require 'exifr'

require 'optparse'

class ExifClassifier
  REFUSAL_REASON = [ :unreadable, :no_exif, :filter ]
  REFUSAL_TEXT   = { :unreadable => 'Unreadable file', :no_exif => 'No EXIF info', :filter => 'Excluded from file filter' } 

  attr_reader :options
  
  def initialize
    @failed_copy        = []
    @succeed_copy       = []
    @staged_images      = []
    @refused_entries    = []
    @staged_directories = []
  end

  def usage
    open(__FILE__).read.grep(/^## ?/).join.gsub(/^## ?/, '')
  end

  def opts_valid?
    return false if @options[:destination].nil? || @options[:sources].empty?
    destination = Pathname.new(@options[:destination])
    destination.mkpath 
    destination.directory?
  end

  def parse_opts
    @options = {
          :pattern => '%Y/%m/%Y%m%d-%H%M%S',
          :delete  => false,
          :dry     => false,
          :verbose => false,
          :accepted_files    => ['jpeg', 'jpg' ],
          :ignore_if_no_exif => true,
          :sources     => '',
          :destination => './'
    }
    opts = OptionParser.new
    opts.banner = usage
    opts.on('-p','--pattern PATTERN', "output pattern") { |pattern| @options[:pattern] = pattern }
    opts.on('-k','--delete', "delete original files once proceed") { @options[:delete] = true } 
    opts.on('-v','--verbose', "verbose") { @options[:verbose] = true } 
    opts.on('-d','--dry', "dry run") { @options[:dry] = true } 
    opts.on('-h','--help', "this help screen") { puts opts; exit(0) } 
    opts.parse!
    # Remainings in ARGV are sources, the last one is the destination
    @options[:destination] = ARGV.delete_at(-1)
    @options[:sources]     = ARGV || []
    if opts_valid?
      stage(@options[:sources])
      return true
    end
    
    puts opts
    exit(-1)
  end

  def report
    content = %{
      Staged files  : #{@staged_images.length}
      Failed files  : #{@failed_copy.length}
      Proceed files : #{@succeed_copy.length}
    }
    puts content
  end

  # stage for processing files or directories, or a mix
  # of those.
  def stage(files_or_directories = [])
    files_or_directories = [files_or_directories] unless files_or_directories.instance_of?(Array)
    files_or_directories.each do |file_or_directory|
      pathname = Pathname.new(file_or_directory)
      puts "Staging #{pathname.to_s}" if @options[:verbose]
      if pathname.directory?
        @staged_directories << pathname
        return stage(pathname.children)
      elsif pathname.readable?
        @staged_images << pathname
      else
        @refused_entries << pathname
        puts "Can't read: #{pathname.to_s}"
        raise file_or_directory.to_s
      end
    end
    puts "#{@staged_images.length} files staged for processing" if @options[:verbose]
    @staged_images.inspect
  end
  
  def get_target_pathname(picture_pathname, number = nil)
    begin
      pattern = EXIFR::JPEG.new(picture_pathname.to_s).date_time.strftime(@options[:pattern])
    rescue RuntimeError => e
      puts "Can't retrieve EXIF from #{picture_pathname}: #{e.message}"
      return nil
    end
    number_suffix = number.nil? ? '' : '_%03d' % number
    pathname = Pathname.new("#{@options[:destination]}/#{pattern}#{number_suffix}#{picture_pathname.extname.downcase}")
    pathname.file? ? get_target_pathname(picture_pathname, number.to_i + 1) : pathname
  end

  def process
    @staged_images.each do |pathname|
      classify(pathname)
    end
    # Remove copied files, then try to remove dirtree under staged directories (from sources given at launch) 
    if @options[:delete]
      @succeed_copy.each { |pathname| pathname.unlink }
      @staged_directories.each(&:children).each do |entry|
        next unless entry.directory?
        begin
          entry.rmdir
        rescue SystemCallError => e
          # There's standard files remaining in the tree
        end
      end
    end
  end

  def classify(picture)
    puts "Classify: #{picture}" if @options[:verbose]
    target_file = get_target_pathname(picture)
    unless target_file
      puts "Abort classification for #{picture}"
      return nil
    end
    # TODO rescue SystemCallError
    target_file.dirname.mkpath
    FileUtils.copy_file(picture.to_s, target_file.to_s, true)
    if FileUtils.compare_file(picture.to_s, target_file.to_s)
      @succeed_copy << picture
    else
      @failed_copy << picture
    end
  end

  def delete_succeed_sources
    @succeed_copy.each { |pathname| Filecopy.rm(pathname.to_sh) }
  end

end

if __FILE__ == $0
  classifier = ExifClassifier.new
  classifier.parse_opts
  classifier.process
  classifier.report
end
